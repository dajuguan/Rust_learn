# Design Requirements
client send req to a kv-server, which can accept CRUD cmd and return response.

- 消息格式: protolbuf(序列化/反序列化)
- client server通讯: stream (TCP, TLS)
    - Server区分消息: 采用frame_id
    - LenDelimitedStream
        - stream
        - wbuf
        - wlen
        - rbuf
        - SinkItem
        - StreamItem
    - Frame:
        - decodeFrame(buf) -> Result<Self>
        - encodeFrame(&self, &mut buf) -> Result<(), KvError>
    - Stream (tcp stream):
    - Sink
- Service
    - client: execute(cmd) -> resp
    - server: process() -> ()
- SecureStream
    - encrypt(&self, nonce:&[u8], plaintext:&[u8]) -> vec<u8>
    - encrypt(&self, nonce:&[u8], ciphertext: &[u8]) -> vec<u8>
    - poll_read() -> 通过缓存状态机来维护从底层tcp读出来的状态，供上层应用透明访问
    - poll_write() -> 同样可以通过缓存状态机来维护写入的数据，供上层应用透明访问
- Dispatcher: execute(self, request) -> Resp
- Storage:
    - get
    - set
    - getIter
- Notification
    - onGetRequest
    - onGetRequestMut
    - onSendReq
    - onSendRespMut
- Pub/Sub
    - stream => yamux stream
    - topic -> subscriberId
    - Server: subscriberId -> sender
    - Client: 如何识别是哪种MSG？

- 通过分析发现数据结构的类型是dispatcher/storage共同依赖的，所以需要先定义好数据结构