# 使用Rust实现简单的多线程PoW挖矿
- 使用Channel发送在线程间发送挖到的数据
- 使用AtomicBool在线程间共享是否挖到的状态
# 要点

· 如何正确地分离生产线程和消费线程？    
- 挖矿线程得到结果后生产，主线程消费

· 如何正确地划分并发任务？
    
- 根据线程个数划分随机数按照steps迭代

· 如何正确地识别临界区，以及如何正确地使用原子类型及其内存顺序？
    
- 产生竞态条件的区域称为临界区，竞态条件指的是执行结果受多线程乱序执行的影响(强调的是代码之间的顺序影响)，数据竞争指的是多个线程同时访问一个变量（即强调一行代码中的一些变量的读写操作)。对于本例，临界区即读写是否挖到结果(finded_solution)的相关代码区。
    - 原子类型多线程共享需要用到Arc::new包裹，并进行clone在多线程传递；由于最终只返回一个结果，且底层的线程执行顺序不会影响find的结果，因此内存顺序为Ordering::Relaxed是安全的，同时还能提高原子操作的性能。
    - Ordering支持5种内存顺序，底层和LLVM编译器的顺序是一致的:
        - Relaxed: 自由顺序。只保证原子操作，但是
        - SeqRst: 排序一致性顺序。要求必须先完成所有写操作，才能完成读操作。优点是可保证多线程操作的全局一致性，缺点是必须等待。
        - 获取释放顺序：不保证多线程的全局唯一性，但是可保证单线程内部读写的序。
            - Release:所有之前的store操作对load操作都是可见的
            - Acquire:所有的load操作对于store操作都是可见的
            - AcqRel:读采用Acquire，写采用Release
   

